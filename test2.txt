#!/use/bin/python
#base python3 code
#-*-coding:utf-8-*-
 
 
from tkinter import *
import threading, time
import tkinter.messagebox
 
# GUI窗口类
class Control:
    # 定义GUI界面
    def __init__(self, master, fuc):
        self.parent = master #Tk的主线程
        self.fuc = fuc #子线程函数
        self.parent.title("title is here")#窗口标题
        self.parent.geometry("300x400")#窗口大小
        self.parent.resizable(0, 0) #不可变更窗口大小
        # tkinter 控件
        self.label1 = Label(self.parent, text="这是Lable 标签")
        self.label1.grid(row=0, column=0)
        #文本框
        self.string1 = StringVar()
        self.string1.set("这里设置文本框内容")
        self.textfiled1 = Entry(self.parent, width =16, textvariable=self.string1)
        self.textfiled1.grid(row=1, column=0)
        #按钮
        self.btn = Button(self.parent, text="运行单次程序", command=self.button_fuc)
        self.btn.grid(row=2, column=0)
        self.btn = Button(self.parent, text="点一下启动一个线程循环程序\n所以启动后要禁用", command=self.fuc)
        self.btn.grid(row=3, column=1)
 
        #多行文本框
        self.txinfo = Text(self.parent, height=10, width=15)
        self.txinfo.grid(row=3, column=0)
        self.txinfo.insert(END,"这里是多行\n内容")
        #多选控件
        self.ynbox = Checkbutton(self.parent, text="是否选择...")
        self.ynbox.grid(row=4,column = 0)
        #组群方块区（可以在此控件上层增加控件）
        self.labelframe1 = LabelFrame(self.parent, width=25, height=30, text="组群方块")
        self.labelframe1.grid(row=0, column=1,rowspan=5, sticky=N) #跨行布局
        self.lfynbox = Checkbutton(self.labelframe1, text="是否选择...")
        self.lfynbox.grid(row=0,column = 0)
 
    #定义停止按钮的功能
    def button_fuc(self):
        #提示对话框
        tkinter.messagebox.showinfo(message="这是消息")
        pass
 
    #定义方法
    def win_msg(self):
        pass
 
    #定义选项功能：
    def select_fuc(self):
        pass
 
# 具体功能类
class ThreadRoot:
    #初始化TK root
    def __init__(self, master):
        self.master = master
        self.gui = Control(self.master, self.starting)
        # 以上将我们定义的GUI类赋给服务类的属性，将执行的功能函数作为参数传入
 
    # 定义线程1
    def threading1(self):
        while thread_state:
            time.sleep(1) #间隔1S
            print("无限循环，不卡机") #可以无限循环而不卡死主进程
 
    # 为方法开第一个单独的线程
    def starting(self):
        #启动线程1
        self.thread1 = threading.Thread(target=self.threading1)
        self.thread1.setDaemon(True)    #线程守护，即主进程结束后，此线程也结束。否则主进程结束子进程不结束
        self.thread1.start()
    ##########################################
    # #定义线程2 和
    # def threading2(self):
    #     pass
    #为方法开第二个单独的线程（没有测试过哈，，原理上Control要传递第三个参数）
    # def starting2(self):
    #     #启动线程2
    #     self.thread1 = threading.Thread(target=self.threading1)
    #     self.thread1.setDaemon(True)    #线程守护，即主进程结束后，此线程也结束。否则主进程结束子进程不结束
    #     self.thread1.start()
    ##########################################
if __name__ == '__main__':
    thread_state = True #子线程循环标识位（可选项）
    root = Tk()
    tool = ThreadRoot(root)
    root.mainloop()
